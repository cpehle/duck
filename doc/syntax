Syntax notes:

For now, the syntax is ocaml-like.

EVERYTHING BEYOND THIS POINT IS WRONG

Scoping is indentation based, and can be explicitly specified via { ; }

Variables are declared via "x = a", which is also an expression with value ().

Expressions are evaluated left to right.

Variables declared inside nested expressions are live outside the expression for the rest of the enclosing function body.  I.e., the following is valid

    y = 5; y
    if b then x = 4 else x = 5
    print x

Shadowing is allowed: "x = 5; x = 6" results in x = 6.  When control flow merges, the set of variables live after the merge is the intersection of the variables before.  I.e.,

    x = y = 0
    for i in 1,2 do
        y = y + i
        if i == 1 then
            x = x + i
    assert (x == 1)
    assert (y == 3)
    # i is not in scope, since for loops can traverse zero elements

Function are declared via "def f x = a" and the like.  Overload restrictions are specified as (x : T).  Here are some examples:

    def f a b = ...
    def f (a : A) b = ...
    def f (a : A) (b : B) = ...

----------------------------------

Here are syntax examples:

def f x =
    y = 4
    y

def power x n =
    def sqr x = x * x
    r = 1
    while n do
        if n&1 then
            r *= x
        n /= 2
        x = sqr x
    r

Note that power is purely functional unless /= and *= are implemented in place.  Everything that looks like assignment is variable shadowing.
