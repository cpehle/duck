A place for miscellaneous notes:

1. Array syntax.  Since a[i] would require whitespace-based parsing, it might be
   reasonable just to use function application syntax for array lookups.  I.e.,
   a i.  This requires overloading application, which we were already planning
   to do (and is straightforward in any case).

   If we go with array _monads_ for mutable arrays, it's possible that "a i" could
   return a helper type that would be usable for both reading and writing.  "a i"
   probably can't be a direct extraction anyways; instead, it would be a monad, and
   reading might look like

      x <- a i

   It's a fairly short leap from there to the idea that "a i" could be overloaded
   to work for reading as well.  Interestingly, the "a i" syntax might otherwise
   be unused on the left side of "<-" in "do" notation, since <- never defines
   functions.

2. It would be useful to eventually have an "explain" function which explains why
   a particular overload is chosen.  E.g., if you do

       f x y

   and don't understand the result,

       explain f x y

   would explain all the overload resolution steps in detail.

3. There's not really any need to hide the overloading concept within named
   functions.  E.g., there could be a combination function overload with a
   type like

       overload :: (a -> b) -> (c -> d) -> (a -> b) | (c -> d)

   or however we decided to denote alternation.

4. Effects might be a better core representation than monads for IO and the like.
   The translation from monads to effects is trivial, and the only advantage of see
   in the IO monad is a nicer algebraic notation for types.

   ...which raises the obvious point: why not expose effect types to the user via
   a convenient algebraic notation (making them identical to monads).

   Let's see:

      print :: String -> IO ()

   Actually, I suppose monads have advantages in terms of optimization.  But the
   basic question remains.

   Ah!  Perhaps the way to proceed is expose monads as MORE of a core type construct.
   GHC translates monads internally into RealWorld threading, but this strikes me as
   basically a hack.  The monad laws don't seem all that complicated, so making them
   primitive might eliminate the complexity.
