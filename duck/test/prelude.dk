-- Duck prelude

---- operator precedence

infixr 9  .
infixr 8  ^, ^^, **
infixl 7  *, /
infixl 6  +, -
infixr 5  :
infix  4  ==, /=, <, <=, >=, >
infixr 3  &&
infixr 2  ||
infixl 1  >>, >>=
infixr 1  =<<
infixr 0  $, $!

---- basic types

data () = ()

data [a] = [] | a : [a]

data Maybe a = Nothing | Just a

---- misc

let id x = x
let f $ x = f x

---- map

over (a -> b) -> Maybe a -> Maybe b
let map f m = case m of
    Nothing -> Nothing
  | Just x -> Just (f x)

over (a -> b) -> [a] -> [b]
let map f l = case l of
    [] -> []
  | x:l -> f x : map f l

---- fold

over (a -> b -> a) -> a -> Maybe b -> a
let fold f x l = case l of
    Nothing -> x
  | Just y -> f x y

over (a -> b -> a) -> a -> [b] -> a
let fold f x l = case l of
    [] -> x
  | y:l -> fold f (f x y) l

---- join

over Maybe (Maybe a) -> Maybe a
let join m = case m of
    Nothing -> Nothing
  | Just Nothing -> Nothing
  | Just (Just x) -> Just x

over [[a]] -> [a]
let join l = case l of
    [] -> []
  | []:l -> join l
  | (x:y):l -> x : join (y:l)

---- arithmetic

-- implicitly declared: (+), (-), (*), (/)

let negate x = 0 - x

let sum = fold (+) 0
let product = fold (*) 1

---- monads

-- TODO: join0 should look something like
--   over a -> a
--   join0 x = x
--
--   over (join :: a -> b) => a -> b
--   join0 x = join x

over a -> a
let join0 x = x

over Maybe (Maybe a) -> Maybe a
let join0 x = join x

over [[a]] -> [a]
let join0 x = join x

-- In Haskell, join0 would be replaced with join.  The use
-- of join0 here avoids the need for return as a separate construct

-- (>>=) :: m a -> (a -> b) -> join0 (m b)
let m >>= f = join0 (map f m)
