-- Duck prelude

---- operator precedence

infixr 90  .
infixr 80  ^ ^^ **
infixl 70  * /
infixl 60  + -
infixr 50  :
infix  40  == != < <= >= >
infixr 30  &&
infixr 20  ||
infixl 10  >> >>=
infixr 10  =<<

--------- miscellaneous basic functions

id x = x

f $ x = f x

(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g x = f (g x)

-------- macros

-- macro Delayed a = ...
-- type Delay a = () -> a

force :: (() -> a) -> a
force x = x ()

delay :: Delayed a -> (() -> a)
delay x = x

--------- basic types and related functions

---- unit

data () of ()

(==) :: () -> () -> Bool
(==) _ _ = True

---- bool

data Bool of False ; True

bool :: Bool -> Bool
bool x = x

(if) :: a -> Delayed b -> Delayed b -> b
(if) c x y = force \ case bool c of
  True -> x
  False -> y

not :: a -> Bool
not x = if x then False else True

(&&) :: a -> Delayed a -> a
x && y = if x then force y else x

(||) :: a -> Delayed a -> a
x || y = if x then x else force y

(==) :: Bool -> Bool -> Bool
x == y = case x of
  False -> not y
  True -> y

(<) :: Bool -> Bool -> Bool
x < y = case x of
  False -> y
  True -> False

---- maybe

data Maybe a of Nothing ; Just a

map :: (a -> b) -> Maybe a -> Maybe b
map f m = case m of
  Nothing -> Nothing
  Just x -> Just (f x)

fold :: (a -> b -> a) -> a -> Maybe b -> a
fold f x l = case l of
  Nothing -> x
  Just y -> f x y

join :: Maybe (Maybe a) -> Maybe a
join m = case m of
  Nothing -> Nothing
  Just Nothing -> Nothing
  Just (Just x) -> Just x

bool :: Maybe a -> Bool
bool x = case x of
  Nothing -> False
  _ -> True

join0 :: Maybe (Maybe a) -> Maybe a
join0 x = join x

(==) :: Maybe a -> Maybe b -> Bool
x == y = case x,y of
  Nothing, Nothing -> True
  Just x, Just y -> x == y
  _ -> False

cmp :: Maybe a -> Maybe b -> Ordering
cmp x y = case x,y of
  Nothing, Nothing -> EQ
  Nothing, Just _ -> LT
  Just _, Nothing -> GT
  Just x, Just y -> cmp x y

---- lists

data List a of
  []
  a : List a

map :: (a -> b) -> List a -> List b
map f l = case l of
  [] -> []
  x:l -> f x : map f l

fold :: (a -> b -> a) -> a -> List b -> a
fold f x l = case l of
  [] -> x
  y:l -> fold f (f x y) l

join :: List (List a) -> List a
join l = case l of
  [] -> []
  []:l -> join l
  (x:y):l -> x : join (y:l)

join0 :: List (List a) -> List a
join0 x = join x

bool :: List a -> Bool
bool x = case x of
  [] -> False
  _ -> True

(==) :: List a -> List b -> Bool
x == y = case x,y of
  [],[] -> True
  x:x',y:y' -> x == y && x' == y'

cmp :: List a -> List b -> Ordering
cmp x y = case x,y of
  [],[] -> EQ
  [],_ -> LT
  _,[] -> GT
  x:x',y:y' -> cmp x y || cmp x' y'

---- tuples

(==) :: a,b -> a',b' -> Bool
(a,b) == (a',b') = a == a' && b == b'

cmp :: a,b -> a',b' -> Ordering
cmp (a,b) (a',b') = cmp a a' || cmp b b'

(==) :: a,b,c -> a',b',c' -> Bool
(a,b,c) == (a',b',c') = a == a' && b == b' && c == c'

cmp :: a,b,c -> a',b',c' -> Ordering
cmp (a,b,c) (a',b',c') = cmp a a' || cmp b b' || cmp c c'

---- orderings

data Ordering of LT ; EQ ; GT

negate :: Ordering -> Ordering
negate x = case x of
  LT -> GT
  EQ -> EQ
  GT -> LT

(==) :: Ordering -> Ordering -> Bool
x == y = case x,y of
  LT,LT -> True
  EQ,EQ -> True
  GT,GT -> True
  _ -> False

(<) :: Ordering -> Ordering -> Bool
x < y = case y of
  LT -> False
  EQ -> x == LT
  GT -> x != GT

bool :: Ordering -> Bool
bool x = x != EQ

-------- comparison

{-
-- Most comparison operators are defined in terms of (==) and (<),
-- which are in turn defined for the types which support them
-}

x != y = not (x == y)
x > y = y < x
x <= y = not (y < x)
x >= y = not (x < y)

{-
-- For large types, using cmp can be more efficient.  cmp and (<)
-- are recursively defined in terms of each other.

-- TODO: This currently loops forever if neither one is given a
-- specialization, and it would be nice to give an error message
-- instead.  Depending on how the type inference semantics turn
-- out, it might be possible to this with the overload restrictions
--
--   cmp :: ((<) :: a -> b -> Bool) -> a -> b -> Ordering
--   (<) :: (cmp :: a -> b -> Ordering) -> a -> b -> Bool
-}

cmp x y =
  if x < y then LT
  else if x == y then EQ
  else GT

x < y = cmp x y == EQ

-------- arithmetic

-- implicitly declared: (+), (-), (*), (/)

negate x = 0 - x

sum = fold (+) 0
product = fold (*) 1

-------- monads

{- TODO: join0 should look something like
over a -> a
join0 x = x

over (join :: a -> b) => a -> b
join0 x = join x
-}

join0 :: a -> a
join0 x = x

{-
-- In Haskell, join0 would be replaced with join.  The use
-- of join0 here avoids the need for return as a separate construct
-}

-- (>>=) :: m a -> (a -> b) -> join0 (m b)
m >>= f = join0 (map f m)

a >> b = a >>= \_ -> b

-------- IO!

{-
-- Since IO is magical, we mention the types here but don't actually declare them.

type IO a = ... 
join :: IO (IO a) -> IO a
map :: (a -> b) -> IO a -> IO b

-- And here are some primitives:

exitFailure :: IO Void 
returnIO :: a -> IO a
testAll :: IO Void
-}

assert x =
  if x then returnIO ()
  else exitFailure
