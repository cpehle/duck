import prelude

over Int -> Int -> Int
let f x y =
  let g y = y * y in
  x + g y

over (Int -> Int) -> Int
let h x = 3

let x = 3
let _ = 4
let a = f x x

let g = \x -> x

-- tuples

let t1,t2,t3 = 1,2,(1,2) :: (Int,Int)
let test_tuple = assert $ (t1,t2,t3) == (1,2,(1,2))

-- lists

let list = 1 : [2, 3, 4]
let one : two : _ = list

let test_sum = assert $ 10 == sum list
let test_cons = assert $ (one,two) == (1,2)

let test_eq1 = assert $ [1,1] == [1,1]
let test_eq2 = assert $ not $ [1,1] == [1,2]

-- test map overloading

let test_map1 = assert $ (map negate [3,4]) == [-3,-4]
let test_map2 = assert $ (map negate (Just 5)) == (Just $ -5)

-- test the list monad

let test_join1 = assert $ join [[]] == []
let test_join2 = assert $ join [[1,2],[3,4]] == [1,2,3,4]

let test_monad = assert $ [11,101,22,202] == (
  [1,2] >>= \a ->
  [10 * a, 100 * a] >>= \b ->
  b + a)

-- test ops

let test_ops1 = assert $ 1 + 2 * 3 == 7
let test_ops2 = assert $ 5 == 1 * 2 + 3

-- toplevel

let main = testAll
