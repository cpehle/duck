import prelude

over Int -> Int -> Int
let f x y =
  let g y = y * y in
  x + g y

over (Int -> Int) -> Int
let h x = 3

let x = 3
let _ = 4
let a = f x x

let g = \x -> x

-- tuples

let t1,t2,t3 = 1,2,(1,2) :: (Int,Int)

-- lists

data List a = Nil | Cons a (List a)

let sum l = case l of
    Nil -> 0
  | Cons x l -> x + sum l

let list = Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil)))
let ten = sum list
let Cons one (Cons two _) = list

over (a -> b) -> List a -> List b
let map f l = case l of
    Nil -> Nil
  | Cons x l -> Cons (f x) (map f l)

-- unordered binary tree

data Tree a = Leaf a | Node (Tree a) (Tree a) 

over (a -> b) -> Tree a -> Tree b
let map f l = case l of
    Leaf x -> Leaf (f x)
  | Node x y -> Node (map f x) (map f y)

-- test list/tree overloading

let negate x = 0 - x

let la = map negate (Cons 3 (Cons 4 Nil))
let ta = map negate (Node (Leaf 1) (Node (Leaf 2) (Leaf 3)))
